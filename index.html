<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Grid Capture — Camera Select (Rear detection fix)</title>
<style>
  :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{margin:0;background:#071023;color:#E6F2F7;display:flex;flex-direction:column;align-items:center;padding:16px;gap:12px;}
  h1{font-size:18px;margin:0}
  .topbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:center;width:92vw;max-width:980px}
  select, input, button{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.07);background:#06202a;color:#e6f2f7}
  button{cursor:pointer;font-weight:700}
  button:disabled{opacity:.45;cursor:not-allowed}
  .stage{position:relative;width:92vw;max-width:720px;border-radius:12px;overflow:hidden;background:#000}
  video, canvas{width:100%;height:auto;display:block}
  .overlayGrid{position:absolute;inset:0;display:grid;pointer-events:auto}
  .cellOverlay{border:1px dashed rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center;color:rgba(255,255,255,0.08);font-weight:800;user-select:none}
  .controls{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;align-items:center}
  .thumbs{display:grid;gap:8px;grid-auto-rows:80px;justify-items:center}
  .thumb{width:80px;height:80px;border-radius:8px;background:#051018;overflow:hidden;border:1px solid rgba(255,255,255,0.04);display:flex;align-items:center;justify-content:center}
  .thumb img{width:100%;height:100%;object-fit:cover;display:block}
  #result{margin-top:10px;border-radius:10px;max-width:92vw}
  .meta{font-size:13px;color:#9fb6c2;text-align:center}
  .small{font-size:13px;color:#9fb6c2}
  .danger{background:#ef4444;color:white}
  label{display:flex;gap:6px;align-items:center}
</style>
</head>
<body>
  <h1>Grid Capture & Stitch — Rear Camera Fix</h1>

  <div class="topbar">
    <label class="small">Camera:
      <select id="cameraSelect"></select>
    </label>
    <button id="refreshDevices">Refresh</button>
    <button id="btnStart">Start</button>
    <button id="btnTryRear">Try Rear (facingMode)</button>
    <button id="btnStop" class="danger" disabled>Stop</button>
  </div>

  <div class="topbar">
    <label class="small">Grid:
      <input id="rows" type="number" min="1" max="6" value="2" style="width:64px">
      ×
      <input id="cols" type="number" min="1" max="6" value="2" style="width:64px">
    </label>

    <label class="small">Delay(ms):
      <input id="delay" type="number" min="20" max="2000" value="200" style="width:80px">
    </label>

    <label class="small">Upscale:
      <input id="upscale" type="number" min="1" max="4" step="0.5" value="2" style="width:80px">
    </label>

    <label class="small">Blend:
      <input id="blend" type="checkbox" checked>
    </label>
  </div>

  <div class="stage" id="stage">
    <video id="preview" autoplay playsinline muted></video>
    <div id="overlayContainer"></div>
  </div>

  <div class="controls">
    <button id="btnAuto" disabled>Auto Snap Grid</button>
    <button id="btnCombine" disabled>Combine</button>
    <button id="btnDownload" disabled>Download</button>
    <button id="btnClear" disabled>Clear</button>
  </div>

  <div style="width:92vw;max-width:720px;">
    <div id="thumbGrid" class="thumbs"></div>
    <canvas id="result"></canvas>
    <div class="meta" id="status">Status: idle — select camera and press Start</div>
  </div>

<script>
(async ()=>{
// elements
const cameraSelect = document.getElementById('cameraSelect');
const refreshDevicesBtn = document.getElementById('refreshDevices');
const btnStart = document.getElementById('btnStart');
const btnTryRear = document.getElementById('btnTryRear');
const btnStop = document.getElementById('btnStop');
const stage = document.getElementById('stage');
const preview = document.getElementById('preview');
const overlayContainer = document.getElementById('overlayContainer');
const rowsInput = document.getElementById('rows');
const colsInput = document.getElementById('cols');
const delayInput = document.getElementById('delay');
const upscaleInput = document.getElementById('upscale');
const blendCheckbox = document.getElementById('blend');
const btnAuto = document.getElementById('btnAuto');
const btnCombine = document.getElementById('btnCombine');
const btnDownload = document.getElementById('btnDownload');
const btnClear = document.getElementById('btnClear');
const thumbGrid = document.getElementById('thumbGrid');
const resultCanvas = document.getElementById('result');
const resultCtx = resultCanvas.getContext('2d');
const status = document.getElementById('status');

let stream = null;
let deviceList = [];
let currentGrid = [];
let lastBlobUrl = null;
const supportsOffscreen = (typeof OffscreenCanvas !== 'undefined');

function setStatus(s){ status.textContent = 'Status: ' + s; }

//
// FIXED device enumeration strategy:
// 1) Ask for permission with a quick getUserMedia favoring environment to make device labels visible
// 2) enumerateDevices()
// 3) stop the temporary stream
// 4) populate the select, prioritizing labels that look like rear cameras
//
async function enumerateVideoDevices(prefetchPermission=true){
  try{
    // If labels are empty, browsers usually require a prior permission grant.
    if(prefetchPermission){
      try{
        setStatus('Requesting temporary camera permission to reveal device labels...');
        const tempStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: 'environment' } }, audio: false });
        // stop immediately but keep permission granted
        tempStream.getTracks().forEach(t => t.stop());
      }catch(e){
        // continue even if permission denied — enumeration may still show device ids but not labels
        console.warn('Temporary permission failed:', e);
      }
    }

    const devices = await navigator.mediaDevices.enumerateDevices();
    deviceList = devices.filter(d => d.kind === 'videoinput');
    cameraSelect.innerHTML = '';
    // heuristics: prefer labels containing these tokens as rear cameras
    const rearTokens = ['back','rear','environment','wide','ultra','main','external'];
    // build a prioritized list: first rear-like, then others
    const prioritized = [...deviceList].sort((a,b)=>{
      const la = (a.label||'').toLowerCase();
      const lb = (b.label||'').toLowerCase();
      const sa = rearTokens.some(t=>la.includes(t)) ? 0 : 1;
      const sb = rearTokens.some(t=>lb.includes(t)) ? 0 : 1;
      if(sa !== sb) return sa - sb;
      // otherwise keep original order
      return 0;
    });
    prioritized.forEach((d,i)=>{
      const opt = document.createElement('option');
      opt.value = d.deviceId;
      opt.textContent = d.label || `Camera ${i+1}`;
      cameraSelect.appendChild(opt);
    });
    if(prioritized.length > 0){
      cameraSelect.selectedIndex = 0;
      setStatus(`Found ${prioritized.length} video input(s). Select camera or use Try Rear.`);
    }else{
      setStatus('No video input devices found.');
    }
  }catch(e){
    console.error('enumerateVideoDevices error', e);
    setStatus('Error listing devices: ' + (e.message || e));
  }
}

async function startCamera(deviceId, useFacingMode=false){
  try{
    if(stream) stopCamera();
    setStatus('Starting camera...');
    // If useFacingMode true, prefer facingMode env without deviceId.
    const constraints = useFacingMode ? {
      video: { facingMode: { ideal: 'environment' }, width: { ideal: 8000 }, height: { ideal: 6000 } },
      audio: false
    } : {
      video: deviceId ? { deviceId: { exact: deviceId } } : { facingMode: { ideal: 'environment' } },
      audio: false
    };
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    preview.srcObject = stream;
    btnStop.disabled = false;
    btnStart.disabled = true;
    btnAuto.disabled = false;
    setStatus('Camera started — preview ready.');
    preview.onloadedmetadata = () => {
      setStatus(`Preview ${preview.videoWidth}×${preview.videoHeight}. Grid: ${rowsInput.value}×${colsInput.value}`);
      buildOverlay();
    };
  }catch(e){
    console.error('startCamera error', e);
    // Helpful troubleshooting messages
    let msg = e && e.name ? e.name + ': ' + (e.message||'') : (e.message || e);
    if(e && (e.name === 'OverconstrainedError' || e.name === 'NotFoundError')){
      msg = 'Requested camera not found. Try "Try Rear (facingMode)" or press Refresh.';
    }
    setStatus('Camera start failed: ' + msg);
    alert('Unable to start camera: ' + msg);
  }
}

function stopCamera(){
  if(stream){
    try{ stream.getTracks().forEach(t=>t.stop()); }catch{}
    stream = null;
    preview.srcObject = null;
    btnStop.disabled = true;
    btnStart.disabled = false;
    btnAuto.disabled = true;
    setStatus('Camera stopped.');
  }
}

// rest of grid/capture/combine logic (kept similar to earlier version)
function buildOverlay(){
  overlayContainer.innerHTML = '';
  const rows = Math.max(1, Math.min(6, parseInt(rowsInput.value||2)));
  const cols = Math.max(1, Math.min(6, parseInt(colsInput.value||2)));
  const overlay = document.createElement('div');
  overlay.className = 'overlayGrid';
  overlay.style.gridTemplateColumns = `repeat(${cols},1fr)`;
  overlay.style.gridTemplateRows = `repeat(${rows},1fr)`;
  overlay.style.position = 'absolute';
  overlay.style.inset = '0';
  overlay.style.zIndex = '2';
  overlay.style.pointerEvents = 'auto';
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const cell = document.createElement('div');
      cell.className = 'cellOverlay';
      cell.dataset.r = r;
      cell.dataset.c = c;
      cell.textContent = `${r+1},${c+1}`;
      cell.addEventListener('click', async (ev)=>{
        ev.stopPropagation();
        await captureCell(r,c);
      });
      overlay.appendChild(cell);
    }
  }
  overlayContainer.appendChild(overlay);
  prepareThumbGrid(rows, cols);
  currentGrid = new Array(rows*cols).fill(null);
  btnCombine.disabled = true;
  btnDownload.disabled = true;
  btnClear.disabled = true;
}

function prepareThumbGrid(rows, cols){
  thumbGrid.innerHTML = '';
  thumbGrid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const wrapper = document.createElement('div');
      wrapper.className = 'thumb';
      wrapper.dataset.r = r; wrapper.dataset.c = c;
      wrapper.title = 'Tap to manually capture this cell';
      wrapper.textContent = `${r+1},${c+1}`;
      wrapper.addEventListener('click', async ()=>{ await captureCell(r,c); });
      thumbGrid.appendChild(wrapper);
    }
  }
}

async function captureFrameBitmap(){
  const track = stream.getVideoTracks()[0];
  if(window.ImageCapture){
    try{
      const ic = new ImageCapture(track);
      if(ic && ic.takePhoto){
        const blob = await ic.takePhoto().catch(()=>null);
        if(blob) return await createImageBitmap(blob);
      }
    }catch(e){ /* fallback */ }
  }
  const w = preview.videoWidth || 1280;
  const h = preview.videoHeight || 720;
  const c = supportsOffscreen ? new OffscreenCanvas(w,h) : document.createElement('canvas');
  c.width = w; c.height = h;
  const ctx = c.getContext('2d');
  ctx.drawImage(preview, 0,0, w,h);
  if(supportsOffscreen) return await c.transferToImageBitmap();
  return await new Promise(res=> c.toBlob(b=> createImageBitmap(b).then(res)));
}

async function captureCell(row, col){
  if(!stream){ alert('Start camera first'); return; }
  try{
    setStatus(`Capturing cell ${row+1},${col+1}...`);
    const bmp = await captureFrameBitmap();
    const w = bmp.width, h = bmp.height;
    const rows = Math.max(1, Math.min(6, parseInt(rowsInput.value||2)));
    const cols = Math.max(1, Math.min(6, parseInt(colsInput.value||2)));
    const cellW = Math.floor(w / cols);
    const cellH = Math.floor(h / rows);
    const sx = Math.floor(col * cellW);
    const sy = Math.floor(row * cellH);
    const oc = supportsOffscreen ? new OffscreenCanvas(cellW, cellH) : document.createElement('canvas');
    oc.width = cellW; oc.height = cellH;
    const ctx = oc.getContext('2d');
    ctx.drawImage(bmp, sx, sy, cellW, cellH, 0, 0, cellW, cellH);
    let cropped;
    if(supportsOffscreen){
      cropped = await oc.transferToImageBitmap();
    }else{
      const blob = await new Promise(res=> oc.toBlob(res, 'image/png'));
      cropped = await createImageBitmap(blob);
    }
    const idx = row * cols + col;
    currentGrid[idx] = cropped;
    showThumbAt(idx, cropped);
    setStatus(`Captured cell ${row+1},${col+1} (${cellW}×${cellH}).`);
    if(currentGrid.every(x=>x)) { btnCombine.disabled = false; btnClear.disabled = false; }
    btnDownload.disabled = true;
  }catch(e){
    console.error(e);
    setStatus('Capture failed: ' + (e.message || e));
  }
}

function showThumbAt(index, bitmap){
  const node = thumbGrid.children[index];
  node.innerHTML = '';
  const tw = 160, th = Math.round(160 * bitmap.height / bitmap.width);
  const oc = supportsOffscreen ? new OffscreenCanvas(tw, th) : document.createElement('canvas');
  oc.width = tw; oc.height = th;
  const ctx = oc.getContext('2d');
  ctx.drawImage(bitmap, 0,0, tw, th);
  if(supportsOffscreen){
    oc.convertToBlob().then(blob=>{
      const url = URL.createObjectURL(blob);
      const img = document.createElement('img');
      img.src = url;
      node.appendChild(img);
    }).catch(e=>{ console.warn(e); });
  }else{
    const img = document.createElement('img');
    img.src = oc.toDataURL('image/png');
    node.appendChild(img);
  }
}

let autoAbort = false;
btnAuto.addEventListener('click', async ()=>{
  if(!stream){ alert('Start camera first'); return; }
  const rows = Math.max(1, Math.min(6, parseInt(rowsInput.value||2)));
  const cols = Math.max(1, Math.min(6, parseInt(colsInput.value||2)));
  const delay = Math.max(20, parseInt(delayInput.value||200));
  autoAbort = false;
  setStatus(`Auto snapping ${rows}×${cols} grid...`);
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(autoAbort){ setStatus('Auto snapping stopped'); return; }
      await captureCell(r,c);
      await new Promise(res => setTimeout(res, delay));
    }
  }
  setStatus('Auto snapping finished.');
});
btnAuto.addEventListener('dblclick', ()=>{ autoAbort = true; });

btnCombine.addEventListener('click', async ()=>{
  if(!currentGrid || currentGrid.some(x=>!x)){
    alert('Capture all grid cells first.');
    return;
  }
  btnCombine.disabled = true;
  setStatus('Combining cells...');
  try{
    const rows = Math.max(1, Math.min(6, parseInt(rowsInput.value||2)));
    const cols = Math.max(1, Math.min(6, parseInt(colsInput.value||2)));
    const upscale = Math.max(1, Math.min(4, parseFloat(upscaleInput.value||2)));
    const cellW = currentGrid[0].width;
    const cellH = currentGrid[0].height;
    const finalW = Math.round(cellW * cols * upscale);
    const finalH = Math.round(cellH * rows * upscale);
    const oc = supportsOffscreen ? new OffscreenCanvas(finalW, finalH) : document.createElement('canvas');
    oc.width = finalW; oc.height = finalH;
    const ctx = oc.getContext('2d');
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const idx = r*cols + c;
        const bmp = currentGrid[idx];
        const dx = Math.round(c * cellW * upscale);
        const dy = Math.round(r * cellH * upscale);
        const dw = Math.round(cellW * upscale);
        const dh = Math.round(cellH * upscale);
        ctx.drawImage(bmp, 0,0, bmp.width, bmp.height, dx, dy, dw, dh);
      }
    }
    if(blendCheckbox.checked){
      try{
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = 0.02;
        for(let pass=0; pass<6; pass++){
          for(let r=0;r<rows;r++){
            for(let c=0;c<cols;c++){
              const idx = r*cols + c;
              const bmp = currentGrid[idx];
              const dx = Math.round(c * cellW * upscale);
              const dy = Math.round(r * cellH * upscale);
              const dw = Math.round(cellW * upscale);
              const dh = Math.round(cellH * upscale);
              ctx.drawImage(bmp, 0,0, bmp.width, bmp.height, dx-1, dy-1, dw+2, dh+2);
            }
          }
        }
        ctx.globalAlpha = 1.0;
        ctx.globalCompositeOperation = 'source-over';
      }catch(e){ /* ignore */ }
    }
    const maxDisplayW = Math.min(1024, finalW);
    const displayW = Math.min(maxDisplayW, Math.round(window.innerWidth * 0.92));
    const displayH = Math.round(displayW * finalH / finalW);
    resultCanvas.width = displayW; resultCanvas.height = displayH;
    if(supportsOffscreen){
      const bmp = await oc.transferToImageBitmap();
      resultCtx.clearRect(0,0,displayW,displayH);
      resultCtx.drawImage(bmp, 0,0, displayW, displayH);
      const blob = await oc.convertToBlob({ type: 'image/png' });
      if(lastBlobUrl) URL.revokeObjectURL(lastBlobUrl);
      lastBlobUrl = URL.createObjectURL(blob);
      btnDownload.disabled = false;
    }else{
      resultCtx.clearRect(0,0,displayW,displayH);
      resultCtx.drawImage(oc, 0,0, displayW, displayH);
      const dataUrl = oc.toDataURL('image/png');
      if(lastBlobUrl) URL.revokeObjectURL(lastBlobUrl);
      const blob = dataURLtoBlob(dataUrl);
      lastBlobUrl = URL.createObjectURL(blob);
      btnDownload.disabled = false;
    }
    setStatus(`Combined image done (${finalW}×${finalH}).`);
  }catch(e){
    console.error(e);
    setStatus('Combine failed: ' + (e.message || e));
  } finally {
    btnCombine.disabled = false;
  }
});

btnDownload.addEventListener('click', ()=>{
  if(!lastBlobUrl){ alert('No combined image yet'); return; }
  const a = document.createElement('a');
  a.href = lastBlobUrl;
  a.download = `grid_combined_${rowsInput.value}x${colsInput.value}.png`;
  a.click();
});

btnClear.addEventListener('click', ()=>{
  const len = currentGrid.length;
  for(let i=0;i<len;i++) currentGrid[i] = null;
  const rows = Math.max(1, Math.min(6, parseInt(rowsInput.value||2)));
  const cols = Math.max(1, Math.min(6, parseInt(colsInput.value||2)));
  for(let i=0;i<rows*cols;i++){
    const n = thumbGrid.children[i];
    if(n){ n.innerHTML = `${Math.floor(i/cols)+1},${(i%cols)+1}`; }
  }
  btnCombine.disabled = true;
  btnDownload.disabled = true;
  btnClear.disabled = true;
  setStatus('Cleared captured cells.');
});

function dataURLtoBlob(dataurl){
  const arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1];
  const bstr = atob(arr[1]); let n = bstr.length; const u8arr = new Uint8Array(n);
  while(n--) u8arr[n] = bstr.charCodeAt(n);
  return new Blob([u8arr], { type: mime });
}

// UI wiring
refreshDevicesBtn.addEventListener('click', ()=> enumerateVideoDevices(true));
cameraSelect.addEventListener('change', ()=> {
  const id = cameraSelect.value;
  if(id) startCamera(id, false);
});
btnStart.addEventListener('click', async ()=> {
  await enumerateVideoDevices(true);
  const id = cameraSelect.value || (deviceList[0] && deviceList[0].deviceId);
  await startCamera(id, false);
});
btnStop.addEventListener('click', stopCamera);

// Try Rear by facingMode — helpful when deviceId is not working
btnTryRear.addEventListener('click', async ()=>{
  await startCamera(null, true);
});

// grid re-build when inputs change
rowsInput.addEventListener('change', buildOverlay);
colsInput.addEventListener('change', buildOverlay);

// initial boot
await enumerateVideoDevices(true);
buildOverlay();
setStatus('Ready — select camera and press Start. If back camera not listed, press "Try Rear (facingMode)".');

// cleanup on unload
window.addEventListener('beforeunload', ()=>{ if(stream) stream.getTracks().forEach(t=>t.stop()); });

})(); // end IIFE
</script>
</body>
</html>
